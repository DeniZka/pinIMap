/* vui.c generated by valac 0.14.2, the Vala compiler
 * generated from vui.vala, do not modify */

/* Copyright 2012+ Denis Badanin <denis.badanin@gmail.com>
 * 
 * This software is licensed under the GNU LGPL (version 2.1 or later).
 * See the COPYING file in this distribution.
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <webkit/webkit.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <glib/gstdio.h>
#include <float.h>
#include <math.h>
#include <gexiv2/gexiv2.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <gdk/gdk.h>


#define TYPE_PINIMAP (pinimap_get_type ())
#define PINIMAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PINIMAP, pinimap))
#define PINIMAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PINIMAP, pinimapClass))
#define IS_PINIMAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PINIMAP))
#define IS_PINIMAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PINIMAP))
#define PINIMAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PINIMAP, pinimapClass))

typedef struct _pinimap pinimap;
typedef struct _pinimapClass pinimapClass;
typedef struct _pinimapPrivate pinimapPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))
#define __g_list_free__gtk_tree_path_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__gtk_tree_path_free0_ (var), NULL)))
#define _g_match_info_free0(var) ((var == NULL) ? NULL : (var = (g_match_info_free (var), NULL)))
#define __g_slist_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_slist_free__g_free0_ (var), NULL)))
#define _gexiv2_metadata_free0(var) ((var == NULL) ? NULL : (var = (gexiv2_metadata_free (var), NULL)))

#define TYPE_APP (app_get_type ())
#define APP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APP, app))
#define APP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APP, appClass))
#define IS_APP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APP))
#define IS_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APP))
#define APP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APP, appClass))

typedef struct _app app;
typedef struct _appClass appClass;
typedef struct _appPrivate appPrivate;

struct _pinimap {
	GObject parent_instance;
	pinimapPrivate * priv;
	GtkWindow* win;
};

struct _pinimapClass {
	GObjectClass parent_class;
};

struct _pinimapPrivate {
	WebKitWebView* Wv;
	GtkTreeView* TVFiles;
	GtkTreeModel* TModel;
	GtkListStore* dataStore;
	GtkEntry* ESearch;
};

struct _app {
	GObject parent_instance;
	appPrivate * priv;
};

struct _appClass {
	GObjectClass parent_class;
};


static gpointer pinimap_parent_class = NULL;
static gpointer app_parent_class = NULL;

GType pinimap_get_type (void) G_GNUC_CONST;
#define PINIMAP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PINIMAP, pinimapPrivate))
enum  {
	PINIMAP_DUMMY_PROPERTY
};
#define PINIMAP_COL_IMG 0
#define PINIMAP_COL_FIL 1
#define PINIMAP_COL_LAT 2
#define PINIMAP_COL_LNG 3
#define PINIMAP_COL_PTH 4
#define PINIMAP_JMSJ_XY "coords"
#define PINIMAP_JMSJ_NO_LOC "no_results"
pinimap* pinimap_new (void);
pinimap* pinimap_construct (GType object_type);
static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self);
static void pinimap_webkit_connect (pinimap* self, GtkBuilder* gbldr);
void pinimap_on_selection_changed (pinimap* self);
static void _pinimap_on_selection_changed_gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self);
gboolean pinimap_on_java_message (pinimap* self, const gchar* message, gint line_number, const gchar* source_id);
static gboolean _pinimap_on_java_message_webkit_web_view_console_message (WebKitWebView* _sender, const gchar* message, gint line_number, const gchar* source_id, gpointer self);
static void _gtk_tree_path_free0_ (gpointer var);
static void _g_list_free__gtk_tree_path_free0_ (GList* self);
void pinimap_on_bopen_click (GtkWidget* source, pinimap* self);
static void _g_free0_ (gpointer var);
static void _g_slist_free__g_free0_ (GSList* self);
void pinimap_on_BSave_clicked (GtkWidget* source, pinimap* self);
void pinimap_on_BClear_clicked (GtkWidget* source, pinimap* self);
void pinimap_on_BSearch_clicked (GtkWidget* source, pinimap* self);
void pinimap_on_ESearch_activate (GtkWidget* source, pinimap* self);
void pinimap_on_ESearch_icon_press (GtkEntryIconPosition p0, GdkEvent* p1, pinimap* self);
void pinimap_on_BCenter_clicked (GtkWidget* source, pinimap* self);
static void pinimap_finalize (GObject* obj);
GType app_get_type (void) G_GNUC_CONST;
enum  {
	APP_DUMMY_PROPERTY
};
gint app_main (gchar** args, int args_length1);
app* app_new (void);
app* app_construct (GType object_type);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self) {
	gtk_main_quit ();
}


static void _pinimap_on_selection_changed_gtk_tree_selection_changed (GtkTreeSelection* _sender, gpointer self) {
	pinimap_on_selection_changed (self);
}


pinimap* pinimap_construct (GType object_type) {
	pinimap * self = NULL;
	GtkBuilder* _tmp0_;
	GtkBuilder* gbldr;
	GError * _inner_error_ = NULL;
	self = (pinimap*) g_object_new (object_type, NULL);
	_tmp0_ = gtk_builder_new ();
	gbldr = _tmp0_;
	{
		GObject* _tmp1_ = NULL;
		GtkWindow* _tmp2_;
		GtkWindow* _tmp3_;
		GObject* _tmp4_ = NULL;
		GtkTreeView* _tmp5_;
		GtkTreeView* _tmp6_;
		GtkTreeModel* _tmp7_ = NULL;
		GtkTreeModel* _tmp8_;
		GtkTreeView* _tmp9_;
		GtkTreeSelection* _tmp10_ = NULL;
		GtkTreeSelection* _tmp11_;
		GtkTreeSelection* ts;
		GtkTreeSelection* _tmp12_;
		GtkTreeSelection* _tmp13_;
		GObject* _tmp14_ = NULL;
		GtkListStore* _tmp15_;
		GObject* _tmp16_ = NULL;
		GtkEntry* _tmp17_;
		gtk_builder_add_from_file (gbldr, "main.glade", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		_tmp1_ = gtk_builder_get_object (gbldr, "WMain");
		_tmp2_ = _g_object_ref0 (GTK_IS_WINDOW (_tmp1_) ? ((GtkWindow*) _tmp1_) : NULL);
		_g_object_unref0 (self->win);
		self->win = _tmp2_;
		_tmp3_ = self->win;
		g_signal_connect ((GtkObject*) _tmp3_, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
		gtk_builder_connect_signals (gbldr, self);
		pinimap_webkit_connect (self, gbldr);
		_tmp4_ = gtk_builder_get_object (gbldr, "TVFiles");
		_tmp5_ = _g_object_ref0 (GTK_IS_TREE_VIEW (_tmp4_) ? ((GtkTreeView*) _tmp4_) : NULL);
		_g_object_unref0 (self->priv->TVFiles);
		self->priv->TVFiles = _tmp5_;
		_tmp6_ = self->priv->TVFiles;
		_tmp7_ = gtk_tree_view_get_model (_tmp6_);
		_tmp8_ = _g_object_ref0 (_tmp7_);
		_g_object_unref0 (self->priv->TModel);
		self->priv->TModel = _tmp8_;
		_tmp9_ = self->priv->TVFiles;
		_tmp10_ = gtk_tree_view_get_selection (_tmp9_);
		_tmp11_ = _g_object_ref0 (_tmp10_);
		ts = _tmp11_;
		_tmp12_ = ts;
		gtk_tree_selection_set_mode (_tmp12_, GTK_SELECTION_MULTIPLE);
		_tmp13_ = ts;
		g_signal_connect_object (_tmp13_, "changed", (GCallback) _pinimap_on_selection_changed_gtk_tree_selection_changed, self, 0);
		_tmp14_ = gtk_builder_get_object (gbldr, "dataStore");
		_tmp15_ = _g_object_ref0 (GTK_IS_LIST_STORE (_tmp14_) ? ((GtkListStore*) _tmp14_) : NULL);
		_g_object_unref0 (self->priv->dataStore);
		self->priv->dataStore = _tmp15_;
		_tmp16_ = gtk_builder_get_object (gbldr, "ESearch");
		_tmp17_ = _g_object_ref0 (GTK_IS_ENTRY (_tmp16_) ? ((GtkEntry*) _tmp16_) : NULL);
		_g_object_unref0 (self->priv->ESearch);
		self->priv->ESearch = _tmp17_;
		_g_object_unref0 (ts);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp18_;
		GError* _tmp19_;
		const gchar* _tmp20_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp18_ = stderr;
		_tmp19_ = e;
		_tmp20_ = _tmp19_->message;
		fprintf (_tmp18_, "Could not load UI: %s\n", _tmp20_);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (gbldr);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_g_object_unref0 (gbldr);
	return self;
}


pinimap* pinimap_new (void) {
	return pinimap_construct (TYPE_PINIMAP);
}


static gboolean _pinimap_on_java_message_webkit_web_view_console_message (WebKitWebView* _sender, const gchar* message, gint line_number, const gchar* source_id, gpointer self) {
	gboolean result;
	result = pinimap_on_java_message (self, message, line_number, source_id);
	return result;
}


static void pinimap_webkit_connect (pinimap* self, GtkBuilder* gbldr) {
	GtkBuilder* _tmp0_;
	GObject* _tmp1_ = NULL;
	GtkScrolledWindow* _tmp2_;
	GtkScrolledWindow* sw;
	WebKitWebView* _tmp3_;
	WebKitWebView* _tmp4_;
	WebKitWebView* _tmp5_;
	WebKitWebView* _tmp6_;
	gchar* doc = NULL;
	WebKitWebView* _tmp11_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (gbldr != NULL);
	_tmp0_ = gbldr;
	_tmp1_ = gtk_builder_get_object (_tmp0_, "sw_browser");
	_tmp2_ = _g_object_ref0 (GTK_IS_SCROLLED_WINDOW (_tmp1_) ? ((GtkScrolledWindow*) _tmp1_) : NULL);
	sw = _tmp2_;
	_tmp3_ = (WebKitWebView*) webkit_web_view_new ();
	_tmp4_ = g_object_ref_sink (_tmp3_);
	_g_object_unref0 (self->priv->Wv);
	self->priv->Wv = _tmp4_;
	_tmp5_ = self->priv->Wv;
	g_signal_connect_object (_tmp5_, "console-message", (GCallback) _pinimap_on_java_message_webkit_web_view_console_message, self, 0);
	_tmp6_ = self->priv->Wv;
	gtk_container_add ((GtkContainer*) sw, (GtkWidget*) _tmp6_);
	{
		gchar* _tmp7_ = NULL;
		g_file_get_contents ("init.html", &_tmp7_, NULL, &_inner_error_);
		_g_free0 (doc);
		doc = _tmp7_;
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		FILE* _tmp8_;
		GError* _tmp9_;
		const gchar* _tmp10_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = stderr;
		_tmp9_ = e;
		_tmp10_ = _tmp9_->message;
		fprintf (_tmp8_, "Error: %s\n", _tmp10_);
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		_g_free0 (doc);
		_g_object_unref0 (sw);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp11_ = self->priv->Wv;
	webkit_web_view_load_html_string (_tmp11_, doc, "");
	_g_free0 (doc);
	_g_object_unref0 (sw);
}


static gpointer _gtk_tree_path_copy0 (gpointer self) {
	return self ? gtk_tree_path_copy (self) : NULL;
}


static gdouble double_parse (const gchar* str) {
	gdouble result = 0.0;
	const gchar* _tmp0_;
	gdouble _tmp1_ = 0.0;
	g_return_val_if_fail (str != NULL, 0.0);
	_tmp0_ = str;
	_tmp1_ = g_ascii_strtod (_tmp0_, NULL);
	result = _tmp1_;
	return result;
}


static void _gtk_tree_path_free0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL));
}


static void _g_list_free__gtk_tree_path_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _gtk_tree_path_free0_, NULL);
	g_list_free (self);
}


gboolean pinimap_on_java_message (pinimap* self, const gchar* message, gint line_number, const gchar* source_id) {
	gboolean result = FALSE;
	FILE* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar** _tmp3_ = NULL;
	gchar** tokens;
	gint tokens_length1;
	gint _tokens_size_;
	gchar** _tmp11_;
	gint _tmp11__length1;
	const gchar* _tmp12_;
	gchar** _tmp44_;
	gint _tmp44__length1;
	const gchar* _tmp45_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	g_return_val_if_fail (source_id != NULL, FALSE);
	_tmp0_ = stderr;
	_tmp1_ = message;
	fprintf (_tmp0_, "Java Message us: %s\n", _tmp1_);
	_tmp2_ = g_strdup ("tmp");
	_tmp3_ = g_new0 (gchar*, 1 + 1);
	_tmp3_[0] = _tmp2_;
	tokens = _tmp3_;
	tokens_length1 = 1;
	_tokens_size_ = tokens_length1;
	{
		GRegex* _tmp4_;
		GRegex* rx;
		const gchar* _tmp5_;
		gchar** _tmp6_;
		gchar** _tmp7_ = NULL;
		_tmp4_ = g_regex_new ("\\s", 0, 0, &_inner_error_);
		rx = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch2_g_regex_error;
			}
			tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
		_tmp5_ = message;
		_tmp7_ = _tmp6_ = g_regex_split (rx, _tmp5_, 0);
		tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
		tokens = _tmp7_;
		tokens_length1 = _vala_array_length (_tmp6_);
		_tokens_size_ = tokens_length1;
		_g_regex_unref0 (rx);
	}
	goto __finally2;
	__catch2_g_regex_error:
	{
		GError* e = NULL;
		FILE* _tmp8_;
		GError* _tmp9_;
		const gchar* _tmp10_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp8_ = stderr;
		_tmp9_ = e;
		_tmp10_ = _tmp9_->message;
		fprintf (_tmp8_, "Error: %s\n", _tmp10_);
		_g_error_free0 (e);
	}
	__finally2:
	if (_inner_error_ != NULL) {
		tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	_tmp11_ = tokens;
	_tmp11__length1 = tokens_length1;
	_tmp12_ = _tmp11_[0];
	if (g_strcmp0 (_tmp12_, PINIMAP_JMSJ_XY) == 0) {
		GtkTreeView* _tmp13_;
		GtkTreeSelection* _tmp14_ = NULL;
		GtkTreeSelection* _tmp15_;
		GtkTreeSelection* ts;
		GtkTreeModel* tm = NULL;
		GtkTreeIter ti = {0};
		GtkTreeSelection* _tmp16_;
		GtkTreeModel* _tmp17_ = NULL;
		GList* _tmp18_ = NULL;
		GtkTreeModel* _tmp19_;
		GList* sl;
		_tmp13_ = self->priv->TVFiles;
		_tmp14_ = gtk_tree_view_get_selection (_tmp13_);
		_tmp15_ = _g_object_ref0 (_tmp14_);
		ts = _tmp15_;
		_tmp16_ = ts;
		_tmp18_ = gtk_tree_selection_get_selected_rows (_tmp16_, &_tmp17_);
		_g_object_unref0 (tm);
		_tmp19_ = _g_object_ref0 (_tmp17_);
		tm = _tmp19_;
		sl = _tmp18_;
		{
			gint i;
			i = 3;
			{
				gboolean _tmp20_;
				_tmp20_ = TRUE;
				while (TRUE) {
					gboolean _tmp21_;
					gint _tmp23_;
					gchar** _tmp24_;
					gint _tmp24__length1;
					GList* _tmp25_;
					_tmp21_ = _tmp20_;
					if (!_tmp21_) {
						gint _tmp22_;
						_tmp22_ = i;
						i = _tmp22_ + 1;
					}
					_tmp20_ = FALSE;
					_tmp23_ = i;
					_tmp24_ = tokens;
					_tmp24__length1 = tokens_length1;
					if (!(_tmp23_ < _tmp24__length1)) {
						break;
					}
					_tmp25_ = sl;
					{
						GList* tp_collection = NULL;
						GList* tp_it = NULL;
						tp_collection = _tmp25_;
						for (tp_it = tp_collection; tp_it != NULL; tp_it = tp_it->next) {
							GtkTreePath* _tmp26_;
							GtkTreePath* tp = NULL;
							_tmp26_ = _gtk_tree_path_copy0 ((GtkTreePath*) tp_it->data);
							tp = _tmp26_;
							{
								GtkTreeModel* _tmp27_;
								GtkTreePath* _tmp28_;
								GtkTreeIter _tmp29_ = {0};
								gchar* name = NULL;
								GtkTreeModel* _tmp30_;
								GtkTreeIter _tmp31_;
								const gchar* _tmp32_;
								gchar** _tmp33_;
								gint _tmp33__length1;
								gint _tmp34_;
								const gchar* _tmp35_;
								_tmp27_ = tm;
								_tmp28_ = tp;
								gtk_tree_model_get_iter (_tmp27_, &_tmp29_, _tmp28_);
								ti = _tmp29_;
								_tmp30_ = tm;
								_tmp31_ = ti;
								gtk_tree_model_get (_tmp30_, &_tmp31_, PINIMAP_COL_FIL, &name, -1);
								_tmp32_ = name;
								_tmp33_ = tokens;
								_tmp33__length1 = tokens_length1;
								_tmp34_ = i;
								_tmp35_ = _tmp33_[_tmp34_];
								if (g_strcmp0 (_tmp32_, _tmp35_) == 0) {
									GtkListStore* _tmp36_;
									GtkTreeIter _tmp37_;
									gchar** _tmp38_;
									gint _tmp38__length1;
									const gchar* _tmp39_;
									gdouble _tmp40_ = 0.0;
									gchar** _tmp41_;
									gint _tmp41__length1;
									const gchar* _tmp42_;
									gdouble _tmp43_ = 0.0;
									_tmp36_ = self->priv->dataStore;
									_tmp37_ = ti;
									_tmp38_ = tokens;
									_tmp38__length1 = tokens_length1;
									_tmp39_ = _tmp38_[1];
									_tmp40_ = double_parse (_tmp39_);
									_tmp41_ = tokens;
									_tmp41__length1 = tokens_length1;
									_tmp42_ = _tmp41_[2];
									_tmp43_ = double_parse (_tmp42_);
									gtk_list_store_set (_tmp36_, &_tmp37_, PINIMAP_COL_LAT, _tmp40_, PINIMAP_COL_LNG, _tmp43_, -1);
									_g_free0 (name);
									_gtk_tree_path_free0 (tp);
									break;
								}
								_g_free0 (name);
								_gtk_tree_path_free0 (tp);
							}
						}
					}
				}
			}
		}
		__g_list_free__gtk_tree_path_free0_0 (sl);
		_g_object_unref0 (tm);
		_g_object_unref0 (ts);
	}
	_tmp44_ = tokens;
	_tmp44__length1 = tokens_length1;
	_tmp45_ = _tmp44_[0];
	if (g_strcmp0 (_tmp45_, PINIMAP_JMSJ_NO_LOC) == 0) {
		GtkEntry* _tmp46_;
		_tmp46_ = self->priv->ESearch;
		gtk_editable_select_region ((GtkEditable*) _tmp46_, 0, -1);
	}
	result = TRUE;
	tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gchar* double_to_string (gdouble self) {
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}


void pinimap_on_selection_changed (pinimap* self) {
	GtkTreeView* _tmp0_;
	GtkTreeSelection* _tmp1_ = NULL;
	GtkTreeSelection* _tmp2_;
	GtkTreeSelection* ts;
	GtkTreeModel* tm = NULL;
	GtkTreeIter ti = {0};
	GtkTreeSelection* _tmp3_;
	GtkTreeModel* _tmp4_ = NULL;
	GList* _tmp5_ = NULL;
	GtkTreeModel* _tmp6_;
	GList* sl;
	WebKitWebView* _tmp7_;
	GList* _tmp8_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->TVFiles;
	_tmp1_ = gtk_tree_view_get_selection (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	ts = _tmp2_;
	_tmp3_ = ts;
	_tmp5_ = gtk_tree_selection_get_selected_rows (_tmp3_, &_tmp4_);
	_g_object_unref0 (tm);
	_tmp6_ = _g_object_ref0 (_tmp4_);
	tm = _tmp6_;
	sl = _tmp5_;
	_tmp7_ = self->priv->Wv;
	webkit_web_view_execute_script (_tmp7_, "clear_markers()");
	_tmp8_ = sl;
	{
		GList* tp_collection = NULL;
		GList* tp_it = NULL;
		tp_collection = _tmp8_;
		for (tp_it = tp_collection; tp_it != NULL; tp_it = tp_it->next) {
			GtkTreePath* _tmp9_;
			GtkTreePath* tp = NULL;
			_tmp9_ = _gtk_tree_path_copy0 ((GtkTreePath*) tp_it->data);
			tp = _tmp9_;
			{
				GtkTreeModel* _tmp10_;
				GtkTreePath* _tmp11_;
				GtkTreeIter _tmp12_ = {0};
				gchar* name = NULL;
				gdouble lat = 0.0;
				gdouble lng = 0.0;
				GtkTreeModel* _tmp13_;
				GtkTreeIter _tmp14_;
				const gchar* _tmp15_;
				gdouble _tmp16_;
				gchar* _tmp17_ = NULL;
				gchar* _tmp18_;
				gdouble _tmp19_;
				gchar* _tmp20_ = NULL;
				gchar* _tmp21_;
				gchar* _tmp22_ = NULL;
				gchar* _tmp23_;
				gchar* outs;
				FILE* _tmp24_;
				const gchar* _tmp25_;
				gchar* _tmp26_;
				gchar* _tmp27_;
				WebKitWebView* _tmp28_;
				const gchar* _tmp29_;
				_tmp10_ = tm;
				_tmp11_ = tp;
				gtk_tree_model_get_iter (_tmp10_, &_tmp12_, _tmp11_);
				ti = _tmp12_;
				_tmp13_ = tm;
				_tmp14_ = ti;
				gtk_tree_model_get (_tmp13_, &_tmp14_, PINIMAP_COL_FIL, &name, PINIMAP_COL_LAT, &lat, PINIMAP_COL_LNG, &lng, -1);
				_tmp15_ = name;
				_tmp16_ = lat;
				_tmp17_ = double_to_string (_tmp16_);
				_tmp18_ = _tmp17_;
				_tmp19_ = lng;
				_tmp20_ = double_to_string (_tmp19_);
				_tmp21_ = _tmp20_;
				_tmp22_ = g_strdup_printf ("file_list = '%s'; add_marker(%s, %s)", _tmp15_, _tmp18_, _tmp21_);
				_tmp23_ = _tmp22_;
				_g_free0 (_tmp21_);
				_g_free0 (_tmp18_);
				outs = _tmp23_;
				_tmp24_ = stderr;
				_tmp25_ = outs;
				_tmp26_ = g_strconcat (_tmp25_, "\n", NULL);
				_tmp27_ = _tmp26_;
				fprintf (_tmp24_, "%s", _tmp27_);
				_g_free0 (_tmp27_);
				_tmp28_ = self->priv->Wv;
				_tmp29_ = outs;
				webkit_web_view_execute_script (_tmp28_, _tmp29_);
				_g_free0 (outs);
				_g_free0 (name);
				_gtk_tree_path_free0 (tp);
			}
		}
	}
	__g_list_free__gtk_tree_path_free0_0 (sl);
	_g_object_unref0 (tm);
	_g_object_unref0 (ts);
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_slist_free__g_free0_ (GSList* self) {
	g_slist_foreach (self, (GFunc) _g_free0_, NULL);
	g_slist_free (self);
}


void pinimap_on_bopen_click (GtkWidget* source, pinimap* self) {
	GtkWindow* _tmp0_;
	GtkFileChooserDialog* _tmp1_;
	GtkFileChooserDialog* _tmp2_;
	GtkFileChooserDialog* odlg;
	GtkFileFilter* _tmp3_;
	GtkFileFilter* _tmp4_;
	GtkFileFilter* fltr;
	GtkFileFilter* _tmp5_;
	GtkFileFilter* _tmp6_;
	GtkFileChooserDialog* _tmp7_;
	GtkFileFilter* _tmp8_;
	GtkFileChooserDialog* _tmp9_;
	GRegex* _tmp10_;
	GRegex* reg;
	GMatchInfo* match = NULL;
	GExiv2Metadata* _tmp11_;
	GExiv2Metadata* exiv2;
	GtkFileChooserDialog* _tmp12_;
	gint _tmp13_ = 0;
	GtkFileChooserDialog* _tmp78_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	_tmp0_ = self->win;
	_tmp1_ = (GtkFileChooserDialog*) gtk_file_chooser_dialog_new ("Select File", _tmp0_, GTK_FILE_CHOOSER_ACTION_OPEN, GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL, NULL);
	_tmp2_ = g_object_ref_sink (_tmp1_);
	odlg = _tmp2_;
	_tmp3_ = gtk_file_filter_new ();
	_tmp4_ = g_object_ref_sink (_tmp3_);
	fltr = _tmp4_;
	_tmp5_ = fltr;
	gtk_file_filter_set_name (_tmp5_, "JPEG Image");
	_tmp6_ = fltr;
	gtk_file_filter_add_mime_type (_tmp6_, "image/jpeg");
	_tmp7_ = odlg;
	_tmp8_ = fltr;
	gtk_file_chooser_add_filter ((GtkFileChooser*) _tmp7_, _tmp8_);
	_tmp9_ = odlg;
	gtk_file_chooser_set_select_multiple ((GtkFileChooser*) _tmp9_, TRUE);
	_tmp10_ = g_regex_new ("[\\w_.-]*?(?=[\\?\\#])|[\\w_.-]*$", 0, 0, &_inner_error_);
	reg = _tmp10_;
	if (_inner_error_ != NULL) {
		_g_object_unref0 (fltr);
		_g_object_unref0 (odlg);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp11_ = gexiv2_metadata_new ();
	exiv2 = _tmp11_;
	_tmp12_ = odlg;
	_tmp13_ = gtk_dialog_run ((GtkDialog*) _tmp12_);
	if (_tmp13_ == ((gint) GTK_RESPONSE_ACCEPT)) {
		GtkFileChooserDialog* _tmp14_;
		GSList* _tmp15_ = NULL;
		GSList* files_name;
		GtkTreeIter iter = {0};
		gchar* path = NULL;
		gchar* name = NULL;
		gdouble alt;
		gdouble lat;
		gdouble lng;
		GExiv2Orientation exor;
		GdkInterpType it;
		GdkPixbufRotation pbrt;
		_tmp14_ = odlg;
		_tmp15_ = gtk_file_chooser_get_filenames ((GtkFileChooser*) _tmp14_);
		files_name = _tmp15_;
		alt = (gdouble) 0;
		lat = (gdouble) 0;
		lng = (gdouble) 0;
		exor = GEXIV2_ORIENTATION_NORMAL;
		it = GDK_INTERP_NEAREST;
		pbrt = GDK_PIXBUF_ROTATE_NONE;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp16_;
				_tmp16_ = TRUE;
				while (TRUE) {
					gboolean _tmp17_;
					gint _tmp19_;
					GSList* _tmp20_;
					guint _tmp21_ = 0U;
					GSList* _tmp22_;
					gint _tmp23_;
					gconstpointer _tmp24_ = NULL;
					gchar* _tmp25_;
					gchar* tm_path = NULL;
					gboolean found;
					GtkListStore* _tmp26_;
					GtkTreeIter _tmp27_ = {0};
					gboolean _tmp28_ = FALSE;
					gboolean _tmp37_;
					GRegex* _tmp39_;
					const gchar* _tmp40_;
					GMatchInfo* _tmp41_ = NULL;
					GMatchInfo* _tmp42_;
					gchar* _tmp43_ = NULL;
					GtkListStore* _tmp55_;
					GtkTreeIter _tmp56_ = {0};
					GExiv2Orientation _tmp57_;
					_tmp17_ = _tmp16_;
					if (!_tmp17_) {
						gint _tmp18_;
						_tmp18_ = i;
						i = _tmp18_ + 1;
					}
					_tmp16_ = FALSE;
					_tmp19_ = i;
					_tmp20_ = files_name;
					_tmp21_ = g_slist_length (_tmp20_);
					if (!(((guint) _tmp19_) < _tmp21_)) {
						break;
					}
					_tmp22_ = files_name;
					_tmp23_ = i;
					_tmp24_ = g_slist_nth_data (_tmp22_, (guint) _tmp23_);
					_tmp25_ = g_strdup ((const gchar*) _tmp24_);
					_g_free0 (path);
					path = _tmp25_;
					found = FALSE;
					_tmp26_ = self->priv->dataStore;
					_tmp28_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) _tmp26_, &_tmp27_);
					iter = _tmp27_;
					if (_tmp28_) {
						{
							gboolean _tmp29_;
							_tmp29_ = TRUE;
							while (TRUE) {
								gboolean _tmp30_;
								GtkTreeModel* _tmp33_;
								GtkTreeIter _tmp34_;
								const gchar* _tmp35_;
								const gchar* _tmp36_;
								_tmp30_ = _tmp29_;
								if (!_tmp30_) {
									GtkTreeModel* _tmp31_;
									gboolean _tmp32_ = FALSE;
									_tmp31_ = self->priv->TModel;
									_tmp32_ = gtk_tree_model_iter_next (_tmp31_, &iter);
									if (!_tmp32_) {
										break;
									}
								}
								_tmp29_ = FALSE;
								_tmp33_ = self->priv->TModel;
								_tmp34_ = iter;
								gtk_tree_model_get (_tmp33_, &_tmp34_, PINIMAP_COL_PTH, &tm_path, -1);
								_tmp35_ = path;
								_tmp36_ = tm_path;
								if (g_strcmp0 (_tmp35_, _tmp36_) == 0) {
									found = TRUE;
									break;
								}
							}
						}
					}
					_tmp37_ = found;
					if (_tmp37_) {
						FILE* _tmp38_;
						_tmp38_ = stderr;
						fprintf (_tmp38_, "Duplicate found!\n");
						_g_free0 (tm_path);
						continue;
					}
					_tmp39_ = reg;
					_tmp40_ = path;
					g_regex_match (_tmp39_, _tmp40_, 0, &_tmp41_);
					_g_match_info_free0 (match);
					match = _tmp41_;
					_tmp42_ = match;
					_tmp43_ = g_match_info_fetch (_tmp42_, 0);
					_g_free0 (name);
					name = _tmp43_;
					{
						GExiv2Metadata* _tmp44_;
						const gchar* _tmp45_;
						GExiv2Metadata* _tmp46_;
						gdouble _tmp47_ = 0.0;
						gdouble _tmp48_ = 0.0;
						gdouble _tmp49_ = 0.0;
						GExiv2Metadata* _tmp50_;
						GExiv2Orientation _tmp51_ = 0;
						_tmp44_ = exiv2;
						_tmp45_ = path;
						gexiv2_metadata_open_path (_tmp44_, _tmp45_, &_inner_error_);
						if (_inner_error_ != NULL) {
							goto __catch3_g_error;
						}
						_tmp46_ = exiv2;
						gexiv2_metadata_get_gps_info (_tmp46_, &_tmp47_, &_tmp48_, &_tmp49_);
						lng = _tmp47_;
						lat = _tmp48_;
						alt = _tmp49_;
						_tmp50_ = exiv2;
						_tmp51_ = gexiv2_metadata_get_orientation (_tmp50_);
						exor = _tmp51_;
					}
					goto __finally3;
					__catch3_g_error:
					{
						GError* e = NULL;
						FILE* _tmp52_;
						GError* _tmp53_;
						const gchar* _tmp54_;
						e = _inner_error_;
						_inner_error_ = NULL;
						_tmp52_ = stderr;
						_tmp53_ = e;
						_tmp54_ = _tmp53_->message;
						fprintf (_tmp52_, "Error: %s\n", _tmp54_);
						_g_error_free0 (e);
					}
					__finally3:
					if (_inner_error_ != NULL) {
						_g_free0 (tm_path);
						_g_free0 (name);
						_g_free0 (path);
						__g_slist_free__g_free0_0 (files_name);
						_gexiv2_metadata_free0 (exiv2);
						_g_match_info_free0 (match);
						_g_regex_unref0 (reg);
						_g_object_unref0 (fltr);
						_g_object_unref0 (odlg);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_tmp55_ = self->priv->dataStore;
					gtk_list_store_append (_tmp55_, &_tmp56_);
					iter = _tmp56_;
					_tmp57_ = exor;
					switch (_tmp57_) {
						case GEXIV2_ORIENTATION_ROT_90:
						{
							pbrt = GDK_PIXBUF_ROTATE_CLOCKWISE;
							break;
						}
						case GEXIV2_ORIENTATION_ROT_180:
						{
							pbrt = GDK_PIXBUF_ROTATE_UPSIDEDOWN;
							break;
						}
						case GEXIV2_ORIENTATION_ROT_270:
						{
							pbrt = GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE;
							break;
						}
						default:
						break;
					}
					{
						const gchar* _tmp58_;
						GdkPixbuf* _tmp59_;
						GdkPixbuf* _tmp60_;
						GdkPixbuf* _tmp61_;
						GdkInterpType _tmp62_;
						GdkPixbuf* _tmp63_ = NULL;
						GdkPixbuf* _tmp64_;
						GdkPixbufRotation _tmp65_;
						GdkPixbuf* _tmp66_ = NULL;
						GdkPixbuf* _tmp67_;
						GdkPixbuf* pb;
						GtkListStore* _tmp68_;
						GtkTreeIter _tmp69_;
						GdkPixbuf* _tmp70_;
						const gchar* _tmp71_;
						gdouble _tmp72_;
						gdouble _tmp73_;
						const gchar* _tmp74_;
						_tmp58_ = path;
						_tmp59_ = gdk_pixbuf_new_from_file (_tmp58_, &_inner_error_);
						_tmp60_ = _tmp59_;
						if (_inner_error_ != NULL) {
							goto __catch4_g_error;
						}
						_tmp61_ = _tmp60_;
						_tmp62_ = it;
						_tmp63_ = gdk_pixbuf_scale_simple (_tmp61_, 40, 40, _tmp62_);
						_tmp64_ = _tmp63_;
						_tmp65_ = pbrt;
						_tmp66_ = gdk_pixbuf_rotate_simple (_tmp64_, _tmp65_);
						_tmp67_ = _tmp66_;
						_g_object_unref0 (_tmp64_);
						_g_object_unref0 (_tmp61_);
						pb = _tmp67_;
						_tmp68_ = self->priv->dataStore;
						_tmp69_ = iter;
						_tmp70_ = pb;
						_tmp71_ = name;
						_tmp72_ = lat;
						_tmp73_ = lng;
						_tmp74_ = path;
						gtk_list_store_set (_tmp68_, &_tmp69_, PINIMAP_COL_IMG, _tmp70_, PINIMAP_COL_FIL, _tmp71_, PINIMAP_COL_LAT, _tmp72_, PINIMAP_COL_LNG, _tmp73_, PINIMAP_COL_PTH, _tmp74_, -1);
						_g_object_unref0 (pb);
					}
					goto __finally4;
					__catch4_g_error:
					{
						GError* e = NULL;
						FILE* _tmp75_;
						GError* _tmp76_;
						const gchar* _tmp77_;
						e = _inner_error_;
						_inner_error_ = NULL;
						_tmp75_ = stderr;
						_tmp76_ = e;
						_tmp77_ = _tmp76_->message;
						fprintf (_tmp75_, "Error: %s\n", _tmp77_);
						_g_error_free0 (e);
					}
					__finally4:
					if (_inner_error_ != NULL) {
						_g_free0 (tm_path);
						_g_free0 (name);
						_g_free0 (path);
						__g_slist_free__g_free0_0 (files_name);
						_gexiv2_metadata_free0 (exiv2);
						_g_match_info_free0 (match);
						_g_regex_unref0 (reg);
						_g_object_unref0 (fltr);
						_g_object_unref0 (odlg);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_g_free0 (tm_path);
				}
			}
		}
		_g_free0 (name);
		_g_free0 (path);
		__g_slist_free__g_free0_0 (files_name);
	}
	_tmp78_ = odlg;
	gtk_object_destroy ((GtkObject*) _tmp78_);
	_gexiv2_metadata_free0 (exiv2);
	_g_match_info_free0 (match);
	_g_regex_unref0 (reg);
	_g_object_unref0 (fltr);
	_g_object_unref0 (odlg);
}


void pinimap_on_BSave_clicked (GtkWidget* source, pinimap* self) {
	FILE* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	_tmp0_ = stderr;
	fprintf (_tmp0_, "SAVING\n");
}


void pinimap_on_BClear_clicked (GtkWidget* source, pinimap* self) {
	GtkListStore* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	_tmp0_ = self->priv->dataStore;
	gtk_list_store_clear (_tmp0_);
}


void pinimap_on_BSearch_clicked (GtkWidget* source, pinimap* self) {
	GtkEntry* _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	gchar* addr;
	const gchar* _tmp3_;
	WebKitWebView* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	_tmp0_ = self->priv->ESearch;
	_tmp1_ = gtk_entry_get_text (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	addr = _tmp2_;
	_tmp3_ = addr;
	if (g_strcmp0 (_tmp3_, "") == 0) {
		_g_free0 (addr);
		return;
	}
	_tmp4_ = self->priv->Wv;
	_tmp5_ = addr;
	_tmp6_ = g_strdup_printf ("request = '%s'; pan_to_address()", _tmp5_);
	_tmp7_ = _tmp6_;
	webkit_web_view_execute_script (_tmp4_, _tmp7_);
	_g_free0 (_tmp7_);
	_g_free0 (addr);
}


void pinimap_on_ESearch_activate (GtkWidget* source, pinimap* self) {
	GtkEntry* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	_tmp0_ = self->priv->ESearch;
	pinimap_on_BSearch_clicked ((GtkWidget*) _tmp0_, self);
}


void pinimap_on_ESearch_icon_press (GtkEntryIconPosition p0, GdkEvent* p1, pinimap* self) {
	GtkEntry* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (p1 != NULL);
	_tmp0_ = self->priv->ESearch;
	pinimap_on_BSearch_clicked ((GtkWidget*) _tmp0_, self);
}


void pinimap_on_BCenter_clicked (GtkWidget* source, pinimap* self) {
	WebKitWebView* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source != NULL);
	_tmp0_ = self->priv->Wv;
	webkit_web_view_execute_script (_tmp0_, "center_markers()");
}


static void pinimap_class_init (pinimapClass * klass) {
	pinimap_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (pinimapPrivate));
	G_OBJECT_CLASS (klass)->finalize = pinimap_finalize;
}


static void pinimap_instance_init (pinimap * self) {
	self->priv = PINIMAP_GET_PRIVATE (self);
}


static void pinimap_finalize (GObject* obj) {
	pinimap * self;
	self = PINIMAP (obj);
	_g_object_unref0 (self->win);
	_g_object_unref0 (self->priv->Wv);
	_g_object_unref0 (self->priv->TVFiles);
	_g_object_unref0 (self->priv->TModel);
	_g_object_unref0 (self->priv->dataStore);
	_g_object_unref0 (self->priv->ESearch);
	G_OBJECT_CLASS (pinimap_parent_class)->finalize (obj);
}


GType pinimap_get_type (void) {
	static volatile gsize pinimap_type_id__volatile = 0;
	if (g_once_init_enter (&pinimap_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (pinimapClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pinimap_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (pinimap), 0, (GInstanceInitFunc) pinimap_instance_init, NULL };
		GType pinimap_type_id;
		pinimap_type_id = g_type_register_static (G_TYPE_OBJECT, "pinimap", &g_define_type_info, 0);
		g_once_init_leave (&pinimap_type_id__volatile, pinimap_type_id);
	}
	return pinimap_type_id__volatile;
}


gint app_main (gchar** args, int args_length1) {
	gint result = 0;
	pinimap* _tmp0_;
	pinimap* h;
	GtkWindow* _tmp1_;
	gtk_init (&args_length1, &args);
	_tmp0_ = pinimap_new ();
	h = _tmp0_;
	_tmp1_ = h->win;
	gtk_widget_show_all ((GtkWidget*) _tmp1_);
	gtk_main ();
	result = 0;
	_g_object_unref0 (h);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return app_main (argv, argc);
}


app* app_construct (GType object_type) {
	app * self = NULL;
	self = (app*) g_object_new (object_type, NULL);
	return self;
}


app* app_new (void) {
	return app_construct (TYPE_APP);
}


static void app_class_init (appClass * klass) {
	app_parent_class = g_type_class_peek_parent (klass);
}


static void app_instance_init (app * self) {
}


GType app_get_type (void) {
	static volatile gsize app_type_id__volatile = 0;
	if (g_once_init_enter (&app_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (appClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) app_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (app), 0, (GInstanceInitFunc) app_instance_init, NULL };
		GType app_type_id;
		app_type_id = g_type_register_static (G_TYPE_OBJECT, "app", &g_define_type_info, 0);
		g_once_init_leave (&app_type_id__volatile, app_type_id);
	}
	return app_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



